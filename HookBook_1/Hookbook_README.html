<h1 id="pset3-ahoy-matey">Pset3: Ahoy Matey!</h1>
<h3 id="due-wed-mar-1-2023">Due Wed, Mar 1 2023</h3>
<p>Ahoy, matey!
This exercise will get you started programming Hookbook.
In this assignment, you will be practicing <strong>file I/O operations</strong>, <strong>structs</strong>, <strong>dynamic memory allocation</strong>, <strong>array lists</strong>, <strong>sorting</strong>, and <strong>software engineering</strong> in C.</p>
<h2 id="the-assignment">The Assignment</h2>
<p>HookBook is a hot new social media platform built for pirates, by pirates (bulldogs are kind of piratey, right?).
To create a HookBook, you&#39;ll load a list of pirates from a file and add them to a list that you&#39;ve created.
For this assignment, the only information about each pirate that you will be given is their name. </p>
<p>However, your swashbuckling clientele is in the process of creating profiles for themselves that they will give you at a later date.
This means that your Hookbook program must easily transform to accept a list of pirates that includes all kinds of additional information about them:</p>
<ul>
<li>Their current vessel of employ</li>
<li>Their current captain (who is another pirate!)</li>
<li>The number of treasures they&#39;ve found</li>
<li>Their favorite port of call</li>
<li>Maybe other things</li>
</ul>
<p>After the list of pirates is loaded by your program, your job will be to display the name of each pirate, sorted in alphabetical order, with each one followed by a newline.</p>
<blockquote>
<p><strong>Note</strong>: As with input, the printing of names only is something of a placeholder until the pirates give you their full profiles.
You&#39;ll be given instructions on how to display the pirates&#39; profiles later, but your program must be ready to easily adapt to that future requirement.</p>
</blockquote>
<h3 id="to-summarize">To summarize</h3>
<p>Your program must:</p>
<ol>
<li>Load a list of pirate names from a file whose name is given to you as a command-line argument</li>
<li>Add those pirates into a list, and sort that list in alphabetical order</li>
<li>Display the names of the pirates, sorted alphabetically</li>
<li>All of the above steps must be taken with the fact in mind that future requirements will increase the information you will hold about each pirate.</li>
</ol>
<h2 id="files-you-are-given">Files you are given</h2>
<ul>
<li><p><code>pirate.h</code> (Type Definition), with the following (partial) type definition.
  You must complete the task marked by <code>TODO</code>.</p>
<pre><code class="language-C">// Type of a pirate
typedef /* TODO: complete this typedef */ pirate;
</code></pre>
</li>
<li><p><code>pirate_list.h</code> (Interface), with the following declarations.
  <strong>You may not change anything in this file</strong>.</p>
<pre><code class="language-C">// Type of a list of pirates
typedef struct implementation pirate_list;
/*
 * Allocate memory for a new pirate_list and return a pointer to it
 */
pirate_list *list_create();

/*
 * Return the index of the pirate with the same name as p, or a value greater than or equal to the length of the list if the pirate is not in the list.
 */
size_t list_index_of(pirate_list* pirates, pirate* p);

/*
 * Only if there is no pirate in the list with the same name as p, insert pirate p into the list at index idx by copying the pointer, shifting the latter part of the list one “slot” to the right.
 * If there is a pirate in the list with the same name as p, do nothing, and return a pointer to the pirate that was not inserted.
 * If the pirate was inserted into the list, return NULL
 */
pirate* list_insert(pirate_list* pirates, pirate* p, size_t idx);

/*
 * Remove the pirate from the list with the same name as p, and return a pointer to it.
 * If there is no pirate in the list with the same name as p, return NULL
 */
pirate* list_remove(pirate_list* pirates, pirate* p);

/*
 * Return a pointer to the pirate pointed to by index idx in the list, or NULL if idx is not a valid index (i.e., it is &gt;= the length of the list).
 */
pirate* list_access(pirate_list* pirates, size_t idx);

/*
 * Sort the list of pirates in alphabetical order by name
 */
void list_sort(pirate_list* pirates);

/*
 * Return the number of pirates in the list.
 */
size_t list_length(pirate_list* pirates);

/*
 * Free all memory associated with the pirate_list, but leave the memory associated with the pirates in the list untouched (it is someone else&#39;s job to free the pirates; maybe that dog with the keys in the Pirates of the Caribbean).
 */
void list_destroy(pirate_list* pirates);
</code></pre>
</li>
<li><p><code>makefile</code> (Incomplete)</p>
<ul>
<li><p>The provided makefile defines two variables, <code>CC</code> and <code>CFLAGS</code>.
  You must submit a makefile having identical values for those two variables:</p>
<pre><code>CC = gcc
CFLAGS = -std=c17 -Wall -Werror -pedantic -g
</code></pre>
</li>
<li><p>The first target, <code>HookBook</code>, is incomplete and you must complete it, however, you must not change its name or its position in the file.</p>
</li>
<li><p>The rest of <code>makefile</code> is up to you.</p>
</li>
</ul>
</li>
</ul>
<h2 id="files-you-must-create">Files you must create</h2>
<ul>
<li><code>hookbook.c</code> (Driver)<ul>
<li>This will be the file where your <code>main</code> function is going to be.
  Your <code>main</code> function must:<ol>
<li>Take as the only command-line argument the path to a file containing the pirates&#39; names who will be placed into our HookBook.</li>
<li>Open that file and read from it the list of pirate names, appearing one on each line, storing them in a <code>pirate_list*</code></li>
<li>Sort the list in <a href="https://wikipedia.org/lexicographic_ordering">lexicographic (TODO: fix link)</a> order by pirate name</li>
<li>Print the sorted list to <code>stdout</code>, with one pirate name per line, following the last pirate&#39;s name with a newline character</li>
<li>Release all resources (files, memory, <em>etc.</em>)</li>
</ol>
</li>
</ul>
</li>
<li><code>pirate_list.c</code> (Implementation), containing a body for every function declared in <code>pirate_list.h</code>, and a definition for <code>struct implementation</code><ul>
<li><code>pirate_list</code> must be implemented as an <strong>array list</strong>, <em>a.k.a.</em> <strong>resizing array</strong></li>
<li>The initial capacity of the list must be defined as a constant named <code>INITIAL_CAPACITY</code>, having value <code>25</code></li>
<li>When the array capacity changes, it must change by a factor of <code>2</code>, which must be the value of a constant named <code>RESIZE_FACTOR</code></li>
<li>In addition to functions declared in <code>pirate_list.h</code>, <code>pirate_list.c</code> must contain a declaration and implementation for each of the following two &quot;helper&quot; functions that are not declared in the header file:<pre><code class="language-C">/*
 * Check if the actual number of pirates in the array is &quot;too large&quot;; if it is, increase the capacity of the array by a factor of RESIZE_FACTOR.
 * If the array capacity was changed, print to stderr the string &quot;Expand to &quot;, followed by the new capacity of the list and a newline. Here is a possible print statement:
 *
 *     fprintf(stderr, &quot;Expand to %zu\n&quot;, new_capacity);
 *
 * If the capacity was not changed, do nothing.
 */
void list_expand_if_necessary(pirate_list* pirates);

/*
 * Check if the actual number of pirates in the array is &quot;too small&quot;; if it is, decrease the capacity of the array by a factor of RESIZE_FACTOR.
 * If the array capacity was changed, print to stderr the string &quot;Contract to &quot; followed by the new capacity of the list. Here is a possible print statement:
 *
 *     fprintf(stderr, Contract to %zu\n, new_capacity);
 *
 * If the capacity was not changed, do nothing.
 *
 * The capacity of the array must never fall below INITIAL_CAPACITY!
 */
void list_contract_if_necessary(pirate_list* pirates);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="other-requirements">Other requirements</h2>
<ul>
<li>If you factor out some or all of the functionality of <code>main</code> into helper functions (such as a function to print the list), you must create a header file and a source file <strong>separate from <code>hookbook.c</code></strong> with their declarations and bodies, respectively.
  The additional files may be named anything you like, but it must be a &quot;good&quot; name to earn full style points.
  We suggest &quot;<code>libhookbook</code>&quot;.</li>
<li>You may modify <code>pirate.h</code> as you see fit (except that there <em>must</em> remain a declaration of a type named <code>pirate</code>).
  This includes declaring functions in that file or making the <code>struct</code> an <strong>opaque struct</strong>.
  If you make such modifications, you must also create a C source file named <code>pirate.c</code> with bodies for functions declared in <code>pirate.h</code> and/or the definition of the opaque struct.</li>
<li>Each header and source file must use <code>#include</code> directives to include things that are <em>directly</em> used by that file&mdash;no more, no less.
  Style points will be deducted for clearly extraneous <code>#include</code> directives or directives that rely on transitive inclusions.</li>
<li>You may not use <code>qsort</code> to sort the list, nor any other pre-implemented sorting function.
  You <strong>must</strong> implement a sorting algorithm on your own, and it must run in $O(n^2)$ time or better and use $O(n)$ additional memory (or less), where $n$ is the number of items in the list.<blockquote>
<p><strong>Note</strong>: These efficiency bounds are quite permissive.
In a later assignmnet you will have an opportunity to implement a faster sorting algorithm, running in average-case $O(n \log n)$ time and using $O(1)$ additional memory.</p>
</blockquote>
</li>
<li>You must create <em>exactly one</em> pirate for each name in the input file&mdash;you may not create copies of pirates (copying <em>pointers</em> to pirates is OK)</li>
</ul>
<h2 id="suggestions-and-notes">Suggestions and Notes</h2>
<ul>
<li>In class, we implemented a naive array list to which you could append and remove <code>int</code>s from just one end.
  Use that to jump start your implementation of <code>pirate_list</code>.</li>
<li>Factor out the functionality of <code>main</code> into several well-named, easily-understood functions</li>
<li>Do not use a raw <code>char*</code> for pirate information&mdash;remember, your program must easily adapt to store additional information about each pirate later on!</li>
<li>To help manage <code>#include</code> directives, draw a &quot;map&quot; of your project&#39;s files, with arrows marking direct dependencies, and use that to write your include directives</li>
<li><code>NULL</code> is a special pointer value that means &quot;points to nothing&quot;.
  Attempting to dereference <code>NULL</code> will result in a segmentation fault, which your program must avoid.</li>
</ul>
<h2 id="correctness">Correctness</h2>
<p>We will release a downloadable testing script on Feb 17 with which you can test that your code conforms to the prescribed output format (which is quite a bit more straightforward than in previous assignments) on a limited set of test cases.
The <code>README</code> file associated with that download will contain instructions for adding your own test cases to the <code>tests</code> directory.
We recommend that you add some to increase the breadth of tests for your project.</p>
<p>Your code will also be tested against an autograder running on Gradescope&#39;s servers.
In the event that your code produces output from the autograder that does not match what you expect&mdash;or if the Gradescope autograder simply does not cooperate&mdash;your submission will be run on the Zoo, which will be treated as the &quot;official&quot; output from your code.
<strong>It is therefore imperative that you test your program on the Zoo to confirm its behavior.</strong></p>
<h3 id="examples">Examples</h3>
<p>Here are several example runs of the program showing the output both to <code>stdout</code> and to <code>stderr</code>.</p>
<ol>
<li><p>File with three names</p>
<blockquote>
<p>File: <code>A_list.txt</code></p>
<pre><code class="language-text">jack sparrow
william turner
elizabeth swan
</code></pre>
</blockquote>
<blockquote>
<p>Command and output:</p>
<pre><code class="language-text">$ ./HookBook A_list.txt
elizabeth swan
jack sparrow
william turner
</code></pre>
</blockquote>
</li>
<li><p>File with 30 names</p>
<blockquote>
<p>File: <code>B_list.txt</code></p>
<pre><code class="language-text">TODO: 30 names here
</code></pre>
</blockquote>
<blockquote>
<p>Command and output:</p>
<pre><code class="language-text">$ ./HookBook B_list.txt
Expand to 50
TODO: 30 names here
</code></pre>
</blockquote>
</li>
</ol>
<h2 id="assumptions">Assumptions</h2>
<p>You may assume the following about the command-line arguments to the program:</p>
<ul>
<li><strong>Nothing!</strong> 
  We will run your program with no command-line arguments, many command-line arguments, and a single command-line argument that is the name of a file that does not exist.
  In all cases where the first command-line argument is not the name of file from which you can read, your program must exit with status code <code>1</code> and not cause any errors such as segmentation faults.</li>
</ul>
<p>You may assume the following about the file referred to by the command-line argument, if you can open it for reading:</p>
<ul>
<li>It is a text file.
  That is, we will not try to open a binary file, <em>e.g.</em>, an image</li>
<li>Every line contains exactly one name</li>
<li>No name in the file will be longer than 64 characters</li>
<li>No name in the file will contain any non-ASCII characters</li>
</ul>
<h2 id="submission">Submission</h2>
<p>Submit your project to Gradescope by uploading all files needed to run your program.
An easy way to do so is by creating a zip file containing those files and uploading that to Gradescope.
Be careful to zip <em>only the files</em>, and not the <em>directory</em> containing those files.</p>
<p>You may also upload the files individually to Gradescope through its upload interface.</p>
